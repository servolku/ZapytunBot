import math
import sys
import os
import json
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from database.models import get_or_create_user, update_score, get_leaderboard

# –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Å–µ—Å—ñ–π –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
USER_SESSION = {}

def calculate_distance(lat1, lon1, lat2, lon2):
    """–û–±—á–∏—Å–ª—é—î –≤—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ –¥–≤–æ–º–∞ —Ç–æ—á–∫–∞–º–∏ (–≤ –º–µ—Ç—Ä–∞—Ö) –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Ñ–æ—Ä–º—É–ª–∏ –ì–∞–≤–µ—Ä—Å–∏–Ω–∞."""
    R = 6371000  # –†–∞–¥—ñ—É—Å –ó–µ–º–ª—ñ –≤ –º–µ—Ç—Ä–∞—Ö
    phi1 = math.radians(lat1)
    phi2 = math.radians(lat2)
    delta_phi = math.radians(lat2 - lat1)
    delta_lambda = math.radians(lon2 - lon1)

    a = math.sin(delta_phi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda / 2) ** 2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    return R * c

async def handle_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–ª—è—î –≥–µ–æ–ª–æ–∫–∞—Ü—ñ—é, —è–∫—É –Ω–∞–¥—Å–∏–ª–∞—î –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á."""
    user_location = update.message.location
    if not user_location:
        await update.message.reply_text("‚ùå –í–∏ –Ω–µ –Ω–∞–¥–∞–ª–∏ –≥–µ–æ–ª–æ–∫–∞—Ü—ñ—é. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")
        return

    user_lat = user_location.latitude
    user_lon = user_location.longitude

    # –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –ø–∏—Ç–∞–Ω–Ω—è
    questions = load_questions()
    user_id = update.effective_user.id

    # –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ —Å–µ—Å—ñ—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —ñ—Å–Ω—É—î
    if user_id not in USER_SESSION:
        await update.message.reply_text("‚ùå –ü–æ–º–∏–ª–∫–∞: –°–µ—Å—ñ—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞.")
        return

    question_index = USER_SESSION[user_id]["current_question"]
    if question_index >= len(questions):
        await update.message.reply_text("‚ùå –ó–∞–≤–¥–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω—ñ. –ü–æ—á–Ω—ñ—Ç—å –Ω–æ–≤—É –≥—Ä—É.")
        return

    # –û—Ç—Ä–∏–º—É—î–º–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∑ –ø–∏—Ç–∞–Ω–Ω—è
    target_question = questions[question_index]
    target_lat = target_question.get("latitude")
    target_lon = target_question.get("longitude")

    if target_lat is None or target_lon is None:
        await update.message.reply_text("‚ùå –î–ª—è —Ü—å–æ–≥–æ –ø–∏—Ç–∞–Ω–Ω—è –Ω–µ –∑–∞–¥–∞–Ω–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.")
        return

    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤—ñ–¥—Å—Ç–∞–Ω—å
    distance = calculate_distance(user_lat, user_lon, target_lat, target_lon)
    if distance <= 20:
        await update.message.reply_text("‚úÖ –í–∏ –∑–Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å —É –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º—É –º—ñ—Å—Ü—ñ! –û—Ç—Ä–∏–º—É—î—Ç–µ –ø–∏—Ç–∞–Ω–Ω—è...")
        await ask_question(update, context)
    else:
        await update.message.reply_text(f"‚ùå –í–∏ –∑–∞–Ω–∞–¥—Ç–æ –¥–∞–ª–µ–∫–æ –≤—ñ–¥ –º—ñ—Å—Ü—è. –ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ–¥—ñ–π–¥—ñ—Ç—å –±–ª–∏–∂—á–µ. –í—ñ–¥—Å—Ç–∞–Ω—å: {distance:.2f} –º–µ—Ç—Ä—ñ–≤.")

def load_questions():
    """–î–∏–Ω–∞–º—ñ—á–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î —Ñ–∞–π–ª –ø–∏—Ç–∞–Ω—å."""
    file_path = "bot/questions.json"
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"–§–∞–π–ª {file_path} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!")
    with open(file_path, "r") as f:
        questions = json.load(f)
        print(f"–ü–∏—Ç–∞–Ω–Ω—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—ñ: {questions}")  # –î–æ–¥–∞–π—Ç–µ —Ü–µ –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏
        return questions

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """–û–±—Ä–æ–±–ª—è—î –∫–æ–º–∞–Ω–¥—É /start."""
     from telegram import KeyboardButton, ReplyKeyboardMarkup
     
     user = update.effective_user
     get_or_create_user(user.id, user.first_name)
     
     # –î–æ–¥–∞—î–º–æ –∫–Ω–æ–ø–∫—É –¥–ª—è –∑–∞–ø–∏—Ç—É –≥–µ–æ–ª–æ–∫–∞—Ü—ñ—ó
     keyboard = [
         [KeyboardButton("–û—Ç—Ä–∏–º–∞—Ç–∏ –ø–∏—Ç–∞–Ω–Ω—è", request_location=True)]
     ]
     reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)
     
     await update.message.reply_text(
         f"–ü—Ä–∏–≤—ñ—Ç, {user.first_name}! –ì–æ—Ç–æ–≤–∏–π —Ä–æ–∑–ø–æ—á–∞—Ç–∏ –∫–≤–µ—Å—Ç?\n"
         "–ù–∞—Ç–∏—Å–Ω–∏ '–û—Ç—Ä–∏–º–∞—Ç–∏ –ø–∏—Ç–∞–Ω–Ω—è', —â–æ–± –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏.",
         reply_markup=reply_markup
     )

async def leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–ª—è—î –∫–æ–º–∞–Ω–¥—É /leaderboard."""
    leaderboard_data = get_leaderboard()
    leaderboard_text = "üèÜ –î–æ—à–∫–∞ –ø–µ—Ä–µ–º–æ–∂—Ü—ñ–≤ üèÜ\n\n"
    for idx, (name, score) in enumerate(leaderboard_data, start=1):
        leaderboard_text += f"{idx}. {name}: {score} –±–∞–ª—ñ–≤\n"
    await update.message.reply_text(leaderboard_text)

async def ask_question(update, context, new_session=False):
    """–í—ñ–¥–ø—Ä–∞–≤–ª—è—î –Ω–∞—Å—Ç—É–ø–Ω–µ –ø–∏—Ç–∞–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É."""
    user_id = update.effective_user.id
    if new_session or user_id not in USER_SESSION:
        USER_SESSION[user_id] = {"current_question": 0, "score": 0}

    # –î–∏–Ω–∞–º—ñ—á–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –ø–∏—Ç–∞–Ω–Ω—è
    questions = load_questions()
    question_index = USER_SESSION[user_id]["current_question"]

    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î —â–µ –ø–∏—Ç–∞–Ω–Ω—è
    if question_index >= len(questions):
        if update.message:
            await update.message.reply_text(
                f"–ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –¢–≤—ñ–π –ø—ñ–¥—Å—É–º–∫–æ–≤–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {USER_SESSION[user_id]['score']} –±–∞–ª—ñ–≤."
            )
        elif update.callback_query:
            await update.callback_query.message.reply_text(
                f"–ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –¢–≤—ñ–π –ø—ñ–¥—Å—É–º–∫–æ–≤–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {USER_SESSION[user_id]['score']} –±–∞–ª—ñ–≤."
            )
        update_score(user_id, USER_SESSION[user_id]["score"])
        del USER_SESSION[user_id]
        return

    question = questions[question_index]
    options = question["options"]

    # –°—Ç–≤–æ—Ä—é—î–º–æ –∫–ª–∞–≤—ñ–∞—Ç—É—Ä—É –¥–ª—è –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π
    keyboard = [
        [InlineKeyboardButton(option, callback_data=str(idx))]
        for idx, option in enumerate(options)
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø–∏—Ç–∞–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É
    if update.message:
        await update.message.reply_text(question["question"], reply_markup=reply_markup)
    elif update.callback_query:
        await update.callback_query.message.reply_text(question["question"], reply_markup=reply_markup)

async def handle_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–ª—è—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞."""
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id

    # –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ —Å–µ—Å—ñ—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —ñ—Å–Ω—É—î
    if user_id not in USER_SESSION:
        await query.edit_message_text(text="‚ùå –ü–æ–º–∏–ª–∫–∞: –°–µ—Å—ñ—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞.")
        return

    # –î–∏–Ω–∞–º—ñ—á–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –ø–∏—Ç–∞–Ω–Ω—è
    questions = load_questions()
    question_index = USER_SESSION[user_id]["current_question"]
    question = questions[question_index]

    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å
    if int(query.data) == question["correct"]:
        USER_SESSION[user_id]["score"] += 1
        response = "‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ!"
    else:
        response = "‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ!"

    # –û–Ω–æ–≤–ª—é—î–º–æ —Ç–µ–∫—Å—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    await query.edit_message_text(text=response)

    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –ø–∏—Ç–∞–Ω–Ω—è
    USER_SESSION[user_id]["current_question"] += 1
    await ask_question(update, context)
