import sys
import os
import json
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from database.models import get_or_create_user, update_score, get_leaderboard

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logger = logging.getLogger(__name__)

# –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Å–µ—Å—ñ–π –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
USER_SESSION = {}

def load_questions():
    """–î–∏–Ω–∞–º—ñ—á–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î —Ñ–∞–π–ª –ø–∏—Ç–∞–Ω—å."""
    file_path = "bot/questions.json"
    if not os.path.exists(file_path):
        logger.error(f"–§–∞–π–ª {file_path} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!")
        raise FileNotFoundError(f"–§–∞–π–ª {file_path} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!")
    try:
        with open(file_path, "r") as f:
            questions = json.load(f)
            return questions
    except Exception as e:
        logger.error(f"Error while loading questions: {e}")
        raise

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        logger.info(f"Received /start command from user: {update.effective_user.id}")
        user = update.effective_user
        get_or_create_user(user.id, user.first_name)
        await update.message.reply_text(
            f"–ü—Ä–∏–≤—ñ—Ç, {user.first_name}! –ì–æ—Ç–æ–≤–∏–π —Ä–æ–∑–ø–æ—á–∞—Ç–∏ –∫–≤–µ—Å—Ç?\n"
            "–í—ñ–¥–ø–æ–≤—ñ–¥–∞–π –Ω–∞ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è, —â–æ–± –∑–∞—Ä–æ–±–∏—Ç–∏ –±–∞–ª–∏!"
        )
        await ask_question(update, context, new_session=True)
    except Exception as e:
        logger.error(f"Error in start command: {e}")
        await update.message.reply_text("‚ùå –í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")

async def leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–ª—è—î –∫–æ–º–∞–Ω–¥—É /leaderboard."""
    try:
        leaderboard_data = get_leaderboard()
        leaderboard_text = "üèÜ –î–æ—à–∫–∞ –ø–µ—Ä–µ–º–æ–∂—Ü—ñ–≤ üèÜ\n\n"
        for idx, (name, score) in enumerate(leaderboard_data, start=1):
            leaderboard_text += f"{idx}. {name}: {score} –±–∞–ª—ñ–≤\n"
        await update.message.reply_text(leaderboard_text)
    except Exception as e:
        logger.error(f"Error in leaderboard command: {e}")
        await update.message.reply_text("‚ùå –í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –¥–æ—à–∫–∏ –ø–µ—Ä–µ–º–æ–∂—Ü—ñ–≤.")

async def ask_question(update, context, new_session=False):
    """–í—ñ–¥–ø—Ä–∞–≤–ª—è—î –Ω–∞—Å—Ç—É–ø–Ω–µ –ø–∏—Ç–∞–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É."""
    try:
        user_id = update.effective_user.id
        if new_session or user_id not in USER_SESSION:
            USER_SESSION[user_id] = {"current_question": 0, "score": 0}

        # –î–∏–Ω–∞–º—ñ—á–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –ø–∏—Ç–∞–Ω–Ω—è
        questions = load_questions()
        question_index = USER_SESSION[user_id]["current_question"]

        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î —â–µ –ø–∏—Ç–∞–Ω–Ω—è
        if question_index >= len(questions):
            if update.message:
                await update.message.reply_text(
                    f"–ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –¢–≤—ñ–π –ø—ñ–¥—Å—É–º–∫–æ–≤–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {USER_SESSION[user_id]['score']} –±–∞–ª—ñ–≤."
                )
            elif update.callback_query:
                await update.callback_query.message.reply_text(
                    f"–ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –¢–≤—ñ–π –ø—ñ–¥—Å—É–º–∫–æ–≤–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {USER_SESSION[user_id]['score']} –±–∞–ª—ñ–≤."
                )
            update_score(user_id, USER_SESSION[user_id]["score"])
            del USER_SESSION[user_id]
            return

        question = questions[question_index]
        options = question["options"]

        # –°—Ç–≤–æ—Ä—é—î–º–æ –∫–ª–∞–≤—ñ–∞—Ç—É—Ä—É –¥–ª—è –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π
        keyboard = [
            [InlineKeyboardButton(option, callback_data=str(idx))]
            for idx, option in enumerate(options)
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø–∏—Ç–∞–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É
        if update.message:
            await update.message.reply_text(question["question"], reply_markup=reply_markup)
        elif update.callback_query:
            await update.callback_query.message.reply_text(question["question"], reply_markup=reply_markup)
    except Exception as e:
        logger.error(f"Error in ask_question function: {e}")
        await update.message.reply_text("‚ùå –í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –ø–∏—Ç–∞–Ω–Ω—è.")

async def handle_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–ª—è—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞."""
    try:
        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id

        # –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ —Å–µ—Å—ñ—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —ñ—Å–Ω—É—î
        if user_id not in USER_SESSION:
            await query.edit_message_text(text="‚ùå –ü–æ–º–∏–ª–∫–∞: –°–µ—Å—ñ—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞.")
            return

        # –î–∏–Ω–∞–º—ñ—á–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –ø–∏—Ç–∞–Ω–Ω—è
        questions = load_questions()
        question_index = USER_SESSION[user_id]["current_question"]
        question = questions[question_index]

        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å
        if int(query.data) == question["correct"]:
            USER_SESSION[user_id]["score"] += 1
            response = "‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ!"
        else:
            response = "‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ!"

        # –û–Ω–æ–≤–ª—é—î–º–æ —Ç–µ–∫—Å—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        await query.edit_message_text(text=response)

        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –ø–∏—Ç–∞–Ω–Ω—è
        USER_SESSION[user_id]["current_question"] += 1
        await ask_question(update, context)
    except Exception as e:
        logger.error(f"Error in handle_answer function: {e}")
        await update.message.reply_text("‚ùå –í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –≤–∞—à–æ—ó –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ.")
